---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by Karl2.
--- DateTime: 2021/6/1 23:39
---

local SpellSession = assert(require("BHElib.sessions.boss.spell_session"))

---@class Nue.spell1:SpellSession
local M = LuaClass("Nue.spell1", SpellSession)

local BossHitbox = require("BHElib.units.enemy.boss_hitbox_prefab")
local Input = require("BHElib.input.input_and_recording")
local Coordinates = require("BHElib.unclassified.coordinates_and_screen")
local Prefab = require("core.prefab")
local RecordingCCButton = require("BHElib.input.recording_cc_button")

M.SPELL_DISPLAY_NAME = "test spell \"æµ‹è¯•ç¬¦å¡\""

---------------------------------------------------------------------------------------------------

local MouseFollower = Prefab.NewX(Prefab.Object)
function MouseFollower:init()
    self.bound = false
    self.group = GROUP_GHOST
end

function MouseFollower:frame()
    local x, y = Input:getRecordedMousePositionInUI()
    self.x, self.y = Coordinates.uiToGame(x, y)
    task.Do(self)
end
Prefab.Register(MouseFollower)

---------------------------------------------------------------------------------------------------

function M.__create(parent, boss)
    local self = SpellSession.__create(parent, boss, 12000, "test_attack")

    self.tuning_ui = self.game_scene.tuning_ui
    self.ui_init_params = {}

    return self
end

function M:ctor()
    local hp = 640
    BossHitbox(16, hp, self)

    local boss = self.boss
    local mouse_follower = MouseFollower()
    self.mouse_follower = mouse_follower

    task.New(self, function()
        boss:move(60, -boss.x, 120 - boss.y, boss.x > 0, self)

        self:initChain()

        lstg.eventDispatcher:addListener("onTuningUIExit", function()
            self:initChain()
        end, 0, tostring(self).."0")

        lstg.eventDispatcher:addListener("reloadChains", function(params)
            self.init_chain_flag = true
        end, 0, tostring(self).."1")

        lstg.eventDispatcher:addListener("onTuningUIEnter", function(params)
            self:removeButtons()
        end, 0, tostring(self).."2")
    end)

    self.buttons = {}
end

function M:endSession()
    self:removeButtons()
    SpellSession.endSession(self)
    lstg.eventDispatcher:removeListenerByTag(tostring(self).."0")
    lstg.eventDispatcher:removeListenerByTag(tostring(self).."1")
    lstg.eventDispatcher:removeListenerByTag(tostring(self).."2")
end

function M:initChain()
    local environment = setmetatable({}, {__index = _G})
    environment.external_objects = self.ui_init_params[1] or {}
    local ScriptEnvironment = require("BHElib.scenes.tuning_stage.default_code.script_environment")
    ScriptEnvironment.AddDefaultEnvironmentAliases(environment)

    local ui_init_params = self.tuning_ui:getChains(nil, environment)
    self.ui_init_params = ui_init_params

    self:initChainFromUIParams()
end

function M:initChainFromUIParams()
    -- cleanup everything
    local boss = self.boss

    task.Clear(boss)  -- clear all matrices' tasks
    task.Clear(self.mouse_follower)

    for _, object in ObjList(GROUP_ENEMY_BULLET) do
        local on_bullet_cancel = object.onBulletCancel
        if on_bullet_cancel then
            on_bullet_cancel(object, self.game_scene)
        end
    end
    self:removeButtons()

    -- re-init everything
    local external_objects, chains, references = unpack(self.ui_init_params)

    self.hot_iter = external_objects.hot_iter

    self:loadButtons()
    self.chains = {}
    self.mouse_chains = {}
    for i = 1, #chains do
        ---@type TuningMatrixIndicesArray
        local indices = references[i]
        for j = 1, indices:getNumIndices() do
            if indices:isBoss(j) then
                table.insert(self.chains, chains[i])
            elseif indices:isMouse(j) then
                table.insert(self.mouse_chains, chains[i])
            end
        end
    end

    if self.tuning_ui.tuning_manager.boss_fire_flag then
        self:fire(boss.x, boss.y)
    end
end

local function ButtonInit()
    return RecordingCCButton(
            "creator/image/default_btn_normal.png",
            "creator/image/default_btn_pressed.png",
            "creator/image/default_btn_disabled.png", 0)
end

function M:loadButtons()
    local hot_iter = self.hot_iter
    if hot_iter == nil then
        return
    end

    local callback_sets = hot_iter:getButtonCallbacks()
    local wadd = 38
    local button_color = cc.c3b(36 + wadd, 22 + wadd, 42 + wadd)
    local wadd_text = 78
    local title_color = cc.c3b(button_color.r + wadd_text, button_color.g + wadd_text, button_color.b + wadd_text)
    local title_font_size = 20
    for i = 1, #callback_sets do
        local base_x, base_y = -108, 500 - 80 * i

        local callbacks = callback_sets[i]
        local onTouchEnded = RecordingCCButton.onTouchEnded
        if callbacks.dimension == 1 then
            -- create 2 buttons
            for j = 1, 2 do
                local button = ButtonInit()
                button:setPositionInUI(base_x + j * 54 + 19, base_y)
                button:setButtonSize(46, 50)
                button:setUseRecordingInput(true)
                button.onTouchEnded = function(self, x, y)
                    callbacks[j]()
                    onTouchEnded(self, x, y)
                end
                button:setColor(button_color)
                self:addButton(button)
                if j == 1 then
                    button:setTitleText(callbacks.label)
                    button:setTitleColor(title_color)
                    button:setTitleFontSize(title_font_size)
                end
            end
        else
            -- create 4 buttons
            for j = 1, 2 do
                local button = ButtonInit()
                button:setPositionInUI(base_x - 12.5 + j * 75, base_y)
                button:setButtonSize(25, 50)
                button:setUseRecordingInput(true)
                button.onTouchEnded = function(self, x, y)
                    callbacks[j]()
                    onTouchEnded(self, x, y)
                end
                button:setColor(button_color)
                self:addButton(button)
                if j == 1 then
                    button:setTitleText(callbacks.label)
                    button:setTitleColor(title_color)
                    button:setTitleFontSize(title_font_size)
                end
            end
            for j = 1, 2 do
                local button = ButtonInit()
                button:setPositionInUI(base_x + 100, base_y + (j - 1.5) * 27)
                button:setButtonSize(44, 22)
                button:setUseRecordingInput(true)
                button.onTouchEnded = function(self, x, y)
                    callbacks[j + 2]()
                    onTouchEnded(self, x, y)
                end
                button:setColor(button_color)
                self:addButton(button)
            end
        end
    end
end

function M:addButton(button)
    local canvas = self.game_scene.canvas
    canvas:addChild(button, 0)
    self.buttons[#self.buttons + 1] = button
end

function M:updateButtons()
    local buttons = self.buttons
    for i = 1, #buttons do
        buttons[i]:update(1)
    end
end

function M:removeButtons()
    local buttons = self.buttons
    for i = 1, #buttons do
        buttons[i]:removeFromParent()
    end
    self.buttons = {}
end

function M:fire()

    PlaySound("se:explode", 0.1, 0, true)

    local chains = self.chains
    for i = 1, #chains do
        local chain = chains[i]
        chain:sparkAll(self.boss)
    end
end

function M:mouseFire()

    PlaySound("se:explode", 0.1, 0, true)

    local chains = self.mouse_chains
    for i = 1, #chains do
        local chain = chains[i]
        chain:sparkAll(self.mouse_follower)
    end
end

function M:update(dt)
    SpellSession.update(self, dt)

    self:updateButtons()
    if self.init_chain_flag then
        self:initChain()
        self.init_chain_flag = nil
    end
    if Input:isMouseButtonJustChanged(true, true) then
        local l, r, b, t = Coordinates.getPlayfieldBoundaryInGame()
        local x, y = self.mouse_follower.x, self.mouse_follower.y
        if x >= l and x <= r and y >= b and y <= t then
            self:mouseFire()
        end
    end
end

return M